{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://webgpu_checkers/./node_modules/gl-matrix/esm/common.js","webpack://webgpu_checkers/./node_modules/gl-matrix/esm/vec3.js","webpack://webgpu_checkers/./node_modules/gl-matrix/esm/mat4.js","webpack://webgpu_checkers/./src/logic/checkersBoard.ts","webpack://webgpu_checkers/./src/view/renderer.ts","webpack://webgpu_checkers/./src/view/shaders/shaders.wgsl","webpack://webgpu_checkers/./src/view/shaders/shaders_pick.wgsl","webpack://webgpu_checkers/./src/logic/camera.ts","webpack://webgpu_checkers/./src/view/assets/ImageMaterial.ts","webpack://webgpu_checkers/./src/view/assets/ObjMesh.ts","webpack://webgpu_checkers/./src/view/assets/lights.ts","webpack://webgpu_checkers/./src/view/scene.ts","webpack://webgpu_checkers/./src/logic/app.ts","webpack://webgpu_checkers/./src/index.ts"],"sourcesContent":["/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;","import { mat4 } from \"gl-matrix\";\nimport { Asset } from \"src/view/assets/assets\";\n\nexport enum CellState {\n    Empty = 0,\n    Klingon = 1, // Player 1\n    Command = 2, // Player 2\n}\n\nexport class CheckersBoard {\n    width: number = 8;\n    height: number = 8;\n    cells: Array<CellState>;\n\n    constructor() {\n        this.cells = new Array<CellState>(this.width * this.height);\n\n        // Init cells\n        this.cells.fill(CellState.Empty);\n\n        // Fill the board\n        // x o x o x o x o\n        // o x o x o x o x\n        // ...\n        for (let i = 0; i < this.cells.length; i++) {\n            const [x, y] = this.get_xy(i);\n            if (x % 2 == y % 2) {\n                if (y < 3) {\n                    this.cells[i] = CellState.Klingon;\n                } else if (y > 4) {\n                    this.cells[i] = CellState.Command;\n                }\n            }\n        }\n\n        console.log(this.cells);\n    }\n\n    public update(device: GPUDevice, klingon: Asset, command: Asset) {\n        // Write model matrices\n        // Coords -> models start at 0,0 (bottom left)\n        // One square is  one square is 0.235x0.235\n\n        // Get position of all klingons\n        [klingon, command].forEach((asset, i) => {\n            const positions = this.cells\n                .map((cell, index) => {\n                    if (cell == i + 1) {\n                        return this.get_xy(index);\n                    }\n                    return undefined;\n                })\n                .filter((pos) => pos != undefined);\n\n            // If length changes overwrite buffer else just update\n            if (positions.length != asset.modelMatrix.length) {\n                // Remove if too long\n                if (positions.length < asset.modelMatrix.length) {\n                    asset.modelMatrix.splice(positions.length);\n                }\n                // Add if too short\n                else {\n                    for (\n                        let j = asset.modelMatrix.length;\n                        j < positions.length;\n                        j++\n                    ) {\n                        asset.modelMatrix.push(mat4.create());\n                    }\n                }\n            }\n\n            // Update model matrices\n            positions.forEach((pos, i) => {\n                const [x, y] = pos as [number, number];\n                mat4.fromTranslation(asset.modelMatrix[i], [\n                    0.235 * y,\n                    -0.235 * x,\n                    0,\n                ]);\n\n                device.queue.writeBuffer(\n                    asset.modelMatrixBuffer,\n                    i * 64,\n                    <ArrayBuffer>asset.modelMatrix[i]\n                );\n            });\n        });\n    }\n\n    get_index(x: number, y: number): number {\n        return this.width * y + x;\n    }\n    num_state(player: CellState): number {\n        return this.cells.filter((cell) => cell == player).length;\n    }\n    get_xy(index: number): [number, number] {\n        return [index % this.width, Math.floor(index / this.width)];\n    }\n\n    get_xy_from_instance(\n        piece: CellState,\n        instance: number\n    ): [number, number] | undefined {\n        // Get instance occupied cell of type piece\n        let found = 0;\n        for (let i = 0; i < this.cells.length; i++) {\n            if (this.cells[i] == piece) {\n                if (found == instance) {\n                    return this.get_xy(i);\n                }\n                found++;\n            }\n        }\n        return undefined;\n    }\n\n    getValidMoves(x: number, y: number): Array<number[]> {\n        // Check if x,y is a valid piece\n        const moves: Array<number[]> = [];\n        const state = this.cells[this.get_index(x, y)];\n        if (state != CellState.Klingon && state != CellState.Command) {\n            return moves;\n        }\n\n        // Determine direction of movement\n        const direction = state == CellState.Klingon ? 1 : -1;\n\n        // Create a list of all possible moves\n\n        const out_of_bounds = (x: number, y: number) => {\n            return x < 0 || y < 0 || x >= this.width || y >= this.height;\n        };\n\n        // 1. Regular moves (diagonal no jump)\n        const reg_moves = [\n            [x - 1, y + direction],\n            [x + 1, y + direction],\n        ];\n        moves.push(\n            ...reg_moves.filter((move) => {\n                const [x, y] = move;\n                if (out_of_bounds(x, y)) return false;\n                if (this.cells[this.get_index(x, y)] != CellState.Empty)\n                    return false;\n                return true;\n            })\n        );\n\n        // 2. Jump moves (diagonal jump)\n        const jump_moves = [\n            [x - 2, y + direction * 2],\n            [x + 2, y + direction * 2],\n        ];\n\n        moves.push(\n            ...jump_moves.filter((move) => {\n                const [x_, y_] = move;\n                // Check if move is in bounds\n                if (out_of_bounds(x_, y_)) return false;\n                // Check if move is empty\n                if (this.cells[this.get_index(x_, y_)] != CellState.Empty)\n                    return false;\n                // Check if enemy is in between\n                const enemy = state == CellState.Klingon ? 2 : 1;\n                const enemy_x = (x + x_) / 2;\n                const enemy_y = (y + y_) / 2;\n                if (this.cells[this.get_index(enemy_x, enemy_y)] != enemy)\n                    return false;\n\n                return true;\n            })\n        );\n        return moves;\n    }\n\n    movePiece(fromX: number, fromY: number, toX: number, toY: number): void {\n        // No validation here\n        const fromIndex = this.get_index(fromX, fromY);\n        const toIndex = this.get_index(toX, toY);\n\n        // Move piece\n        this.cells[toIndex] = this.cells[fromIndex];\n        this.cells[fromIndex] = CellState.Empty;\n\n        // Check if piece is captured\n        const enemy = this.cells[toIndex] == CellState.Klingon ? 2 : 1;\n        const enemy_x = (fromX + toX) / 2;\n        const enemy_y = (fromY + toY) / 2;\n        const enemy_index = this.get_index(enemy_x, enemy_y);\n        if (this.cells[enemy_index] == enemy) {\n            this.cells[enemy_index] = CellState.Empty;\n        }\n    }\n}\n","import shaderCode from \"./shaders/shaders.wgsl\";\nimport shaderCodePick from \"./shaders/shaders_pick.wgsl\";\n\nimport { Camera } from \"src/logic/camera\";\n\nimport { Scene } from \"./scene\";\n\nexport class Renderer {\n    canvas: HTMLCanvasElement;\n    scene: Scene;\n    camera: Camera;\n\n    // GPU context\n    device: GPUDevice;\n    context: GPUCanvasContext;\n    adapter: GPUAdapter;\n    format: GPUTextureFormat;\n\n    // Render pipeline\n    pipeline: GPURenderPipeline;\n\n    // Picking pipeline\n    pickPipeline: GPURenderPipeline;\n    pickUniformBuffer: GPUBuffer;\n    pickBindGroupLayout: GPUBindGroupLayout;\n    pickBindGroups: Map<string, GPUBindGroup>;\n    pickMapReadBuffer: GPUBuffer;\n\n    // Depth\n    depthStencilState: GPUDepthStencilState;\n    depthStencilBuffer: GPUTexture;\n    depthStencilView: GPUTextureView;\n    depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n    // Assets\n    assetBindGroupLayout: GPUBindGroupLayout; // Layout is the same for all meshes/materials\n    assetBindGroups: Map<string, GPUBindGroup>; // One bind group per asset\n\n    // Camera\n    cameraBindGroupLayout: GPUBindGroupLayout;\n    cameraBindGroup: GPUBindGroup;\n\n    // Lighting\n    lightsBindGroupLayout: GPUBindGroupLayout;\n    lightsBindGroup: GPUBindGroup;\n    timeBuffer: GPUBuffer;\n\n    constructor(\n        canvas: HTMLCanvasElement,\n        initialScene: Scene,\n        initialCamera: Camera\n    ) {\n        this.canvas = canvas;\n        this.scene = initialScene;\n        this.camera = initialCamera;\n        this.assetBindGroups = new Map<string, GPUBindGroup>();\n        this.pickBindGroups = new Map<string, GPUBindGroup>();\n    }\n\n    public async init() {\n        // Setup the device and gpu context\n        await this.setupWebgpu();\n\n        // Create bind group layouts\n        await this.createBindGroupLayouts();\n\n        // Init scene assets\n        await this.scene.init(this.device);\n        await this.camera.init(this.device, this.canvas);\n\n        await this.createDepthBufferResources();\n\n        // Create bind groups\n        await this.createBindGroups();\n\n        // Create render pipeline\n        await this.createRenderPipeline();\n    }\n\n    public async render() {\n        // Early exit\n        if (!this.device || !this.pipeline) {\n            return;\n        }\n\n        this.device.queue.writeBuffer(\n            this.timeBuffer,\n            0,\n            new Float32Array([performance.now() / 1000])\n        );\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const renderPass = commandEncoder.beginRenderPass({\n            colorAttachments: [\n                {\n                    view: this.context.getCurrentTexture().createView(),\n                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n                    storeOp: \"store\",\n                    loadOp: \"clear\",\n                },\n            ],\n            depthStencilAttachment: this.depthStencilAttachment,\n        });\n\n        renderPass.setPipeline(this.pipeline);\n        renderPass.setBindGroup(0, this.lightsBindGroup); // @group(0)\n        renderPass.setBindGroup(1, this.cameraBindGroup); // @group(1)\n\n        // Draw scene assets\n        for (const [name, asset] of this.scene.assets) {\n            const num_instances = asset.modelMatrix.length;\n            renderPass.setBindGroup(\n                2,\n                this.assetBindGroups.get(name) as GPUBindGroup\n            ); // @group(2)\n            renderPass.setVertexBuffer(0, asset.mesh.buffer);\n            renderPass.draw(asset.mesh.num_vertices, num_instances);\n        }\n\n        renderPass.end();\n        this.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public async getObjectID(pixelX: number, pixelY: number) {\n        const pickInstanceTexture = this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height, 1],\n            format: \"r32uint\",\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        const pickIDTexture = this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height, 1],\n            format: \"r32uint\",\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        const pickDepthTexture = this.device.createTexture({\n            size: [this.canvas.width, this.canvas.height, 1],\n            format: \"depth24plus\",\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n\n        const commandEncoder = this.device.createCommandEncoder();\n        const passEncoder = commandEncoder.beginRenderPass({\n            colorAttachments: [\n                {\n                    view: pickInstanceTexture.createView(),\n                    clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    loadOp: \"clear\",\n                    storeOp: \"store\",\n                },\n                {\n                    view: pickIDTexture.createView(),\n                    clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    loadOp: \"clear\",\n                    storeOp: \"store\",\n                },\n            ],\n            depthStencilAttachment: {\n                view: pickDepthTexture.createView(),\n                depthClearValue: 1,\n                depthLoadOp: \"clear\",\n                depthStoreOp: \"store\",\n            },\n        });\n        passEncoder.setPipeline(this.pickPipeline);\n        passEncoder.setBindGroup(0, this.cameraBindGroup); // @group(1)\n\n        for (const [name, asset] of this.scene.assets) {\n            const num_instances = asset.modelMatrix.length;\n            passEncoder.setBindGroup(\n                1,\n                this.pickBindGroups.get(name) as GPUBindGroup\n            ); // @group(1)\n            passEncoder.setVertexBuffer(0, asset.mesh.buffer);\n            passEncoder.draw(asset.mesh.num_vertices, num_instances);\n        }\n        passEncoder.end();\n        commandEncoder.copyTextureToBuffer(\n            {\n                mipLevel: 0,\n                texture: pickInstanceTexture,\n                origin: { x: pixelX, y: pixelY },\n            },\n            {\n                buffer: this.pickMapReadBuffer,\n                bytesPerRow: ((4 + 255) | 0) * 256,\n                rowsPerImage: 1,\n            },\n            {\n                width: 1,\n            }\n        );\n        commandEncoder.copyTextureToBuffer(\n            {\n                mipLevel: 0,\n                texture: pickIDTexture,\n                origin: { x: pixelX, y: pixelY },\n            },\n            {\n                buffer: this.pickMapReadBuffer,\n                bytesPerRow: ((4 + 255) | 0) * 256,\n                rowsPerImage: 1,\n                offset: 4,\n            },\n            {\n                width: 1,\n            }\n        );\n\n        this.device.queue.submit([commandEncoder.finish()]);\n        await this.pickMapReadBuffer.mapAsync(GPUMapMode.READ, 0, 8);\n        const pickedId = new Uint32Array(\n            this.pickMapReadBuffer.getMappedRange(0, 8)\n        );\n        const pickedInstance = pickedId[0];\n        const pickedMesh = pickedId[1];\n        this.pickMapReadBuffer.unmap();\n        return [pickedInstance, pickedMesh] as [number, number];\n    }\n\n    public async resize(width: number, height: number) {\n        if (!this.device || !this.pipeline) {\n            return;\n        }\n        const ratio = window.devicePixelRatio || 1;\n        this.canvas.width = width * ratio;\n        this.canvas.height = height * ratio;\n\n        this.camera.canvas_resize(this.device, this.canvas);\n\n        await this.createDepthBufferResources();\n    }\n\n    private async setupWebgpu() {\n        if (!navigator.gpu) throw new Error(\"WebGPU not supported\");\n\n        const adapter = await navigator.gpu.requestAdapter();\n        if (!adapter) throw Error(\"Couldn't request WebGPU adapter.\");\n        this.adapter = adapter;\n\n        this.device = await this.adapter.requestDevice();\n        if (!this.device) throw Error(\"Couldn't request WebGPU device.\");\n\n        const context = this.canvas.getContext(\"webgpu\");\n        if (!context) throw Error(\"Couldn't get WebGPU context.\");\n        this.context = context;\n        this.format = \"bgra8unorm\";\n        this.context.configure({\n            device: this.device,\n            format: this.format,\n            alphaMode: \"opaque\",\n        });\n    }\n\n    private async createBindGroupLayouts() {\n        // Create lights bind group\n        this.lightsBindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: \"uniform\",\n                    },\n                },\n            ],\n        });\n\n        // Create asset bind group\n        this.assetBindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    //sampler\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    //texture view\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {},\n                },\n                {\n                    //uniform buffer (instance model matrix)\n                    binding: 2,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n                {\n                    //uniform buffer (highlight)\n                    binding: 3,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n            ],\n        });\n\n        // Create camera bind group\n        this.cameraBindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: \"uniform\",\n                    },\n                },\n            ],\n        });\n\n        // Create pick bind group\n        this.pickBindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: \"uniform\",\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: \"read-only-storage\",\n                    },\n                },\n            ],\n        });\n    }\n\n    public async createDepthBufferResources() {\n        if (this.depthStencilState == undefined) {\n            this.depthStencilState = {\n                format: \"depth24plus-stencil8\",\n                depthWriteEnabled: true,\n                depthCompare: \"less-equal\",\n            };\n        }\n\n        const depthBufferDescriptor: GPUTextureDescriptor = {\n            size: {\n                width: this.canvas.width,\n                height: this.canvas.height,\n                depthOrArrayLayers: 1,\n            },\n            format: \"depth24plus-stencil8\",\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        };\n        this.depthStencilBuffer = this.device!.createTexture(\n            depthBufferDescriptor\n        );\n\n        const viewDescriptor: GPUTextureViewDescriptor = {\n            format: \"depth24plus-stencil8\",\n            dimension: \"2d\",\n            aspect: \"all\",\n        };\n        this.depthStencilView =\n            this.depthStencilBuffer.createView(viewDescriptor);\n\n        this.depthStencilAttachment = {\n            view: this.depthStencilView,\n            depthClearValue: 1.0,\n            depthLoadOp: \"clear\",\n            depthStoreOp: \"store\",\n\n            stencilLoadOp: \"clear\",\n            stencilStoreOp: \"discard\",\n        };\n    }\n\n    private async createBindGroups() {\n        // Create bind group for the lights\n\n        this.timeBuffer = this.device.createBuffer({\n            size: 4,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.lightsBindGroup = this.device.createBindGroup({\n            layout: this.lightsBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.scene.lights.buffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.timeBuffer,\n                    },\n                },\n            ],\n        });\n\n        // Create a bind group for the scene assets\n        for (const [name, asset] of this.scene.assets) {\n            const bindGroup = this.device.createBindGroup({\n                layout: this.assetBindGroupLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: asset.material.sampler,\n                    },\n                    {\n                        binding: 1,\n                        resource: asset.material.textureView,\n                    },\n                    {\n                        binding: 2,\n                        resource: {\n                            buffer: asset.modelMatrixBuffer,\n                        },\n                    },\n                    {\n                        binding: 3,\n                        resource: {\n                            buffer: asset.highlightBuffer,\n                        },\n                    },\n                ],\n            });\n            this.assetBindGroups.set(name, bindGroup);\n        }\n\n        // Create camera bind group\n        this.cameraBindGroup = this.device.createBindGroup({\n            layout: this.cameraBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.camera.buffer,\n                    },\n                },\n            ],\n        });\n\n        // Create pick bind group\n        let i = 1; // 0 is reserved for the background\n        for (const [name, asset] of this.scene.assets) {\n            const pickUniformBuffer = this.device.createBuffer({\n                size: 4, // 4 bytes uint32\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n            this.device.queue.writeBuffer(\n                pickUniformBuffer,\n                0,\n                new Uint32Array([i])\n            );\n            const pickBindGroup = this.device.createBindGroup({\n                layout: this.pickBindGroupLayout,\n                entries: [\n                    {\n                        binding: 0,\n                        resource: {\n                            buffer: pickUniformBuffer,\n                        },\n                    },\n                    {\n                        binding: 1,\n                        resource: {\n                            buffer: asset.modelMatrixBuffer,\n                        },\n                    },\n                ],\n            });\n            this.pickBindGroups.set(name, pickBindGroup);\n            i++;\n        }\n        this.pickMapReadBuffer = this.device.createBuffer({\n            size: 8, // 4 bytes uint32 * 2\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n    }\n\n    private async createRenderPipeline() {\n        // Create shader module\n        const shaderModule = this.device.createShaderModule({\n            label: \"RenderShaderModule\",\n            code: shaderCode,\n        });\n\n        // Create render pipeline layout\n        const layout = this.device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.lightsBindGroupLayout,\n                this.cameraBindGroupLayout,\n                this.assetBindGroupLayout,\n            ],\n        });\n\n        // Create render pipeline\n        this.pipeline = this.device.createRenderPipeline({\n            label: \"renderPipeline\",\n            layout: layout,\n            depthStencil: this.depthStencilState,\n            vertex: {\n                module: shaderModule,\n                entryPoint: \"vertexMain\",\n                buffers: [\n                    {\n                        arrayStride: 32,\n                        attributes: [\n                            {\n                                // position\n                                shaderLocation: 0,\n                                offset: 0,\n                                format: \"float32x3\",\n                            },\n                            {\n                                // texture coordinates\n                                shaderLocation: 1,\n                                offset: 12,\n                                format: \"float32x2\",\n                            },\n                            {\n                                // normal\n                                shaderLocation: 2,\n                                offset: 20,\n                                format: \"float32x3\",\n                            },\n                        ],\n                    },\n                ],\n            },\n            fragment: {\n                module: shaderModule,\n                entryPoint: \"fragmentMain\",\n                targets: [\n                    {\n                        format: this.format,\n                        blend: {\n                            color: {\n                                srcFactor: \"src-alpha\",\n                                dstFactor: \"one-minus-src-alpha\",\n                                operation: \"add\",\n                            },\n                            alpha: {\n                                srcFactor: \"src-alpha\",\n                                dstFactor: \"one-minus-src-alpha\",\n                                operation: \"add\",\n                            },\n                        },\n                    },\n                ],\n            },\n        });\n        const shaderCodeModule = this.device.createShaderModule({\n            label: \"PickShaderModule\",\n            code: shaderCodePick,\n        });\n        const layoutPick = this.device.createPipelineLayout({\n            bindGroupLayouts: [\n                this.cameraBindGroupLayout,\n                this.pickBindGroupLayout,\n            ],\n        });\n\n        // Create pipeline layout\n        this.pickPipeline = this.device.createRenderPipeline({\n            label: \"PickerPipeline\",\n            layout: layoutPick,\n            vertex: {\n                module: shaderCodeModule,\n                entryPoint: \"pickingVertexMain\",\n                buffers: [\n                    {\n                        arrayStride: 32,\n                        attributes: [\n                            {\n                                // position\n                                shaderLocation: 0,\n                                offset: 0,\n                                format: \"float32x3\",\n                            },\n                            {\n                                // texture coordinates\n                                shaderLocation: 1,\n                                offset: 12,\n                                format: \"float32x2\",\n                            },\n                            {\n                                // normal\n                                shaderLocation: 2,\n                                offset: 20,\n                                format: \"float32x3\",\n                            },\n                        ],\n                    },\n                ],\n            },\n            fragment: {\n                module: shaderCodeModule,\n                entryPoint: \"pickingFragmentMain\",\n                targets: [{ format: \"r32uint\" }, { format: \"r32uint\" }],\n            },\n            primitive: {\n                topology: \"triangle-list\",\n                cullMode: \"back\",\n            },\n            depthStencil: {\n                depthWriteEnabled: true,\n                depthCompare: \"less\",\n                format: \"depth24plus\",\n            },\n        });\n    }\n}\n","export default \"// Everything static in the scene (lighting, projection)\\nstruct PointLight {\\n    position : vec3f, // offset(0) align(16) size(12)\\n    color : vec3f, // offset(16) align(16) size(12)\\n};\\nstruct LightStorage {\\n    pointCount : u32, // offset(0) align(4) size(4)\\n    @align(16) point : array<PointLight> // offset(16) align(16) size(24)\\n};\\n@group(0) @binding(0) var<storage> lights : LightStorage;\\n@group(0) @binding(1) var<uniform> time : f32;\\n\\nstruct Camera {\\n    projection : mat4x4f,\\n    view : mat4x4f,\\n    pos: vec4f,\\n};\\n@group(1) @binding(0) var<uniform> camera : Camera;\\n\\n\\n\\n// Texture, sampler and everything regarding the current vertices\\n@group(2) @binding(0) var baseColorSampler : sampler;\\n@group(2) @binding(1) var baseColorTexture : texture_2d<f32>;\\n@group(2) @binding(2) var<storage> instanceBuffer : array<mat4x4f>; // Model matrix for each instance\\n@group(2) @binding(3) var<storage> highlightBuffer : array<u32>; // Model matrix for each instance\\n\\n// The remainder of this shader doesn't affect the bind groups.\\nstruct VertexOutput {\\n    @builtin(position) position : vec4f,\\n    @location(0) texcoord : vec2f,\\n    @location(1) normal : vec3f,\\n    @location(2) instanceID : u32,\\n};\\n\\n\\n@vertex \\nfn vertexMain(\\n    @builtin(instance_index) ID : u32,\\n    @location(0) position : vec3f,\\n    @location(1) texcoord : vec2f,\\n    @location(2) normal : vec3f,\\n) -> VertexOutput {\\n    var output : VertexOutput;\\n    // Todo determine model matrix via gameboard\\n    output.position = camera.projection * camera.view * instanceBuffer[ID] * vec4f(position, 1.0);\\n    output.texcoord = texcoord;\\n    output.normal = normal;\\n    output.instanceID = ID;\\n    return output;\\n}\\n\\n\\n\\n@fragment\\nfn fragmentMain(\\n    fragData: VertexOutput\\n) -> @location(0) vec4f {\\n    // Sample the base color of the surface from a texture.\\n    var baseColor = textureSample(baseColorTexture, baseColorSampler, fragData.texcoord);\\n\\n    let N = normalize(fragData.normal.xyz);\\n    let viewDir = normalize(camera.pos - fragData.position);\\n    var surfaceColor = vec3f(0.2);\\n\\n    // directional light from top\\n    let lightDir = normalize(vec3f(0.0, 0.0, 1.0));\\n    let diff = max(dot(N, lightDir), 0.0);\\n    let ambient = vec3f(0.1) * 1.0;\\n    let diffuse = vec3f(1.) * diff * 0.8;\\n    let result = ambient + diffuse;\\n    surfaceColor += result;\\n\\n    // point lights\\n    for (var i = 0u; i < lights.pointCount; i++) {\\n        surfaceColor += calcPointLight(fragData, lights.point[i], N, viewDir.xyz);\\n    }\\n\\n    // Apply the base color to the surface.\\n    surfaceColor *= baseColor.rgb;\\n\\n    // Hihglight blinking\\n    if (highlightBuffer[fragData.instanceID] == 1u) {\\n         // Oscillate alpha between 0.5 and 1 ease in and out\\n        let alpha = 0.5 + 0.5 * abs(sin(time * 3.));\\n        surfaceColor += vec3f(0.8, 0.1, 0.1) * alpha;\\n    }\\n\\n    // Preview of turn\\n\\n    // Return the accumulated surface color.\\n    return vec4f(surfaceColor, baseColor.a);\\n}\\n\\n\\nfn calcPointLight(fragData: VertexOutput, light: PointLight, N: vec3f, viewDir: vec3f) -> vec3f {\\n    // Add as group at some point\\n    let DIFFUSE = vec3f(1.0) * light.color.rgb;\\n    let AMBIENT = vec3f(1.0) * light.color.rgb;\\n    let SPECULAR = vec3f(1.0) * light.color.rgb;\\n    let SHININESS = 100.0;\\n    // point let config (could also be moved to a storage buffer)\\n    let CONSTANT = 1.0;\\n    let LINEAR = 0.09;\\n    let QUARDRATIC = 0.032;\\n\\n    let lightDir = normalize(light.position.xyz - fragData.position.xyz);\\n    // diffuse shading\\n    let diff = max(dot(N, lightDir), 0.0);\\n    // specular shading\\n    let reflectDir = reflect(-lightDir, N);\\n    let spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);\\n    // attenuation\\n    let distance = length(light.position.xyz - fragData.position.xyz) / 80.0;\\n    let attenuation = 1.0 / (CONSTANT + LINEAR * distance + QUARDRATIC * (distance * distance));\\n\\n    // combine results\\n    var ambient = AMBIENT  * 1.0 * attenuation;\\n    var diffuse = DIFFUSE * diff * 1.0 * attenuation;\\n    var specular = SPECULAR * spec * 1.0 * attenuation;\\n\\n    let result = ambient + diffuse + specular;\\n    return result;\\n}\"","export default \"struct Camera {\\n    projection : mat4x4f,\\n    view : mat4x4f,\\n    pos: vec4f,\\n};\\n@group(0) @binding(0) var<uniform> camera : Camera;\\n\\n\\n@group(1) @binding(0) var<uniform> pickUniform : u32; // Picking ID\\n@group(1) @binding(1) var<storage> instanceBuffer : array<mat4x4f>; // Model matrix for each instance\\n\\n// The remainder of this shader doesn't affect the bind groups.\\nstruct VertexOutput {\\n    @builtin(position) position : vec4f,\\n    @location(0) texcoord : vec2f,\\n    @location(1) normal : vec3f,\\n    @location(2) instanceID : u32\\n};\\n\\n\\n@vertex \\nfn pickingVertexMain(\\n    @builtin(instance_index) ID : u32,\\n    @location(0) position : vec3f,\\n    @location(1) texcoord : vec2f,\\n    @location(2) normal : vec3f,\\n) -> VertexOutput {\\n    var output : VertexOutput;\\n    // Todo determine model matrix via gameboard\\n    output.position = camera.projection * camera.view * instanceBuffer[ID] * vec4f(position, 1.0);\\n    output.texcoord = texcoord;\\n    output.normal = normal;\\n    output.instanceID = ID;\\n    return output;\\n}\\n\\n\\n\\nstruct ReturnFragment {\\n    @location(0) instance_id : u32,\\n    @location(1) pickID : u32\\n};\\n\\n@fragment\\nfn pickingFragmentMain(\\n    fragData: VertexOutput\\n) -> ReturnFragment {\\n    var r : ReturnFragment;\\n    r.instance_id = fragData.instanceID;\\n    r.pickID = pickUniform;\\n    return r;\\n}\\n\"","import { mat4, vec3 } from \"gl-matrix\";\n\n/** Describes camera struct in shaders.wgsl\n *  struct Camera {\n *       projection : matrix4x4f,\n *       view : matrix4x4f,\n *       position: vec3f,\n *   };\n *\n */\nexport class Camera {\n    buffer: GPUBuffer;\n\n    // Camera data\n    projection: mat4;\n    view: mat4;\n    position: vec3;\n    look_at: vec3;\n\n    // Camera data\n    mouse_down: boolean = false;\n    mouse_x: number = 0;\n    mouse_y: number = 0;\n\n    constructor() {\n        // Create initial projection\n        this.projection = mat4.create();\n        this.view = mat4.create();\n        this.position = vec3.create();\n    }\n\n    public async init(device: GPUDevice, canvas: HTMLCanvasElement) {\n        // Perspective projection\n        mat4.perspective(\n            this.projection,\n            Math.PI / 4,\n            canvas.width / canvas.height,\n            0.1,\n            1000.0\n        );\n\n        // Initial position for camera\n        this.position = vec3.fromValues(0, 0, 100);\n        this.look_at = vec3.fromValues(0, 0, 0);\n        mat4.lookAt(this.view, this.position, this.look_at, [0, 0, 1]);\n\n        // Create buffer\n        const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n        const descriptor: GPUBufferDescriptor = {\n            label: \"Camera\",\n            size: 64 * 2 + 16, // 64 bytes for each matrix, 12 bytes for vec4f\n            usage: usage,\n        };\n\n        this.buffer = device.createBuffer(descriptor);\n\n        // Write initial data\n        this.writeBuffer(device);\n    }\n    public writeBuffer(device: GPUDevice) {\n        // Write data\n        device.queue.writeBuffer(this.buffer, 0, <ArrayBuffer>this.projection);\n        device.queue.writeBuffer(this.buffer, 64, <ArrayBuffer>this.view);\n        device.queue.writeBuffer(this.buffer, 128, <ArrayBuffer>this.position);\n    }\n\n    public canvas_resize(device: GPUDevice, canvas: HTMLCanvasElement) {\n        // Perspective projection\n        const pixelRatio = window.devicePixelRatio || 1;\n        mat4.perspective(\n            this.projection,\n            Math.PI / 4,\n            (canvas.width * pixelRatio) / (canvas.height * pixelRatio),\n            0.1,\n            1000.0\n        );\n\n        // Write data\n        device.queue.writeBuffer(this.buffer, 0, <ArrayBuffer>this.projection);\n    }\n\n    set_position(pos: vec3) {\n        this.position = pos;\n        mat4.lookAt(this.view, this.position, this.look_at, [0, 0, 1]);\n    }\n\n    set_look_at(look_at: vec3) {\n        this.look_at = look_at;\n        mat4.lookAt(this.view, this.position, this.look_at, [0, 0, 1]);\n    }\n}\n","export interface Material {\n    texture: GPUTexture;\n    textureView: GPUTextureView;\n    sampler: GPUSampler;\n\n    init(device: GPUDevice): Promise<void>;\n}\n\n/** A material that is loaded from an image file.\n */\nexport class ImageMaterial implements Material {\n    texture: GPUTexture;\n    textureView: GPUTextureView;\n    sampler: GPUSampler;\n\n    path: string;\n    rotation: number;\n    verticalFlip: boolean;\n    horizontalFlip: boolean;\n\n    constructor(\n        path: string,\n        rotation: number = 0,\n        verticalFlip: boolean = false,\n        horizontalFlip: boolean = false\n    ) {\n        this.path = path;\n        this.rotation = rotation;\n        this.verticalFlip = verticalFlip;\n        this.horizontalFlip = horizontalFlip;\n    }\n\n    async init(device: GPUDevice) {\n        var imageData = await fetch(this.path)\n            .then(async (response) => {\n                return await response.blob();\n            })\n            .then(async (blob) => {\n                return await createImageBitmap(blob);\n            });\n\n        // Apply rotation\n        if (this.rotation != 0) {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\")!;\n            canvas.width = imageData.width;\n            canvas.height = imageData.height;\n            ctx.translate(canvas.width / 2, canvas.height / 2);\n            ctx.rotate((this.rotation * Math.PI) / 180);\n            ctx.drawImage(\n                imageData,\n                -imageData.width / 2,\n                -imageData.height / 2\n            );\n            imageData = await createImageBitmap(canvas);\n        }\n\n        // Apply flips\n        if (this.verticalFlip || this.horizontalFlip) {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\")!;\n            canvas.width = imageData.width;\n            canvas.height = imageData.height;\n            if (this.verticalFlip) {\n                ctx.translate(0, canvas.height);\n                ctx.scale(1, -1);\n            }\n            if (this.horizontalFlip) {\n                ctx.translate(canvas.width, 0);\n                ctx.scale(-1, 1);\n            }\n            ctx.drawImage(imageData, 0, 0);\n            imageData = await createImageBitmap(canvas);\n        }\n\n        await this.loadImageBitmap(device, imageData);\n\n        const viewDescriptor: GPUTextureViewDescriptor = {\n            format: \"rgba8unorm\",\n            dimension: \"2d\",\n            aspect: \"all\",\n            baseMipLevel: 0,\n            mipLevelCount: 1,\n            baseArrayLayer: 0,\n            arrayLayerCount: 1,\n        };\n        this.textureView = this.texture.createView(viewDescriptor);\n\n        const samplerDescriptor: GPUSamplerDescriptor = {\n            addressModeU: \"repeat\",\n            addressModeV: \"repeat\",\n            magFilter: \"linear\",\n            minFilter: \"nearest\",\n            mipmapFilter: \"nearest\",\n            maxAnisotropy: 1,\n        };\n        this.sampler = device.createSampler(samplerDescriptor);\n    }\n\n    private async loadImageBitmap(device: GPUDevice, imageData: ImageBitmap) {\n        const textureDescriptor: GPUTextureDescriptor = {\n            size: [imageData.width, imageData.height],\n            format: \"rgba8unorm\",\n            usage:\n                GPUTextureUsage.TEXTURE_BINDING |\n                GPUTextureUsage.COPY_DST |\n                GPUTextureUsage.RENDER_ATTACHMENT,\n        };\n        this.texture = device.createTexture(textureDescriptor);\n\n        device.queue.copyExternalImageToTexture(\n            { source: imageData },\n            { texture: this.texture },\n            textureDescriptor.size\n        );\n    }\n}\n","import { vec3, vec2 } from \"gl-matrix\";\n\nexport interface Mesh {\n    buffer: GPUBuffer;\n    bufferLayout: GPUVertexBufferLayout;\n    num_vertices: number;\n\n    init(device: GPUDevice): Promise<void>;\n}\n\n/** This is a simple obj loader, it only supports\n * vertices, texcoords and normals.\n */\nexport class ObjMesh implements Mesh {\n    buffer: GPUBuffer;\n    bufferLayout: GPUVertexBufferLayout;\n    num_vertices: number;\n\n    v: vec3[];\n    vt: vec2[];\n    vn: vec3[];\n    vertices: Float32Array;\n    path: string;\n\n    constructor(path: string) {\n        this.v = [];\n        this.vt = [];\n        this.vn = [];\n        this.path = path;\n    }\n\n    public async init(device: GPUDevice) {\n        const lines = await this.fetch_obj(this.path);\n        var result: number[] = [];\n\n        lines.forEach((line) => {\n            //console.log(line);\n            if (line[0] == \"v\" && line[1] == \" \") {\n                this.read_vertex_data(line);\n            } else if (line[0] == \"v\" && line[1] == \"t\") {\n                this.read_texcoord_data(line);\n            } else if (line[0] == \"v\" && line[1] == \"n\") {\n                this.read_normal_data(line);\n            } else if (line[0] == \"f\") {\n                this.read_face_data(line, result);\n            }\n        });\n\n        // x y z u v nx ny nz\n        this.vertices = new Float32Array(result);\n        this.num_vertices = this.vertices.length / 8;\n\n        const usage = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST;\n        const descriptor: GPUBufferDescriptor = {\n            label: \"Obj vertices\" + this.path,\n            size: this.vertices.byteLength,\n            usage: usage,\n        };\n\n        this.buffer = device.createBuffer(descriptor);\n        device.queue.writeBuffer(\n            this.buffer,\n            /*bufferOffset=*/ 0,\n            this.vertices\n        );\n        this.bufferLayout = {\n            arrayStride: 32,\n            attributes: [\n                {\n                    format: \"float32x3\",\n                    offset: 0,\n                    shaderLocation: 0,\n                },\n                {\n                    format: \"float32x2\",\n                    offset: 12,\n                    shaderLocation: 1, // Texcoord, see vertex shader\n                },\n                {\n                    format: \"float32x3\",\n                    offset: 20,\n                    shaderLocation: 2, // Normal, see vertex shader\n                },\n            ],\n        };\n    }\n\n    private async fetch_obj(path: string) {\n        return await fetch(path)\n            .then((response) => response.blob())\n            .then((blob) => blob.text())\n            .then((text) => text.split(\"\\n\"));\n    }\n\n    private read_vertex_data(line: string) {\n        const components = line.split(\" \");\n        // [\"v\", \"x\", \"y\", \"z\"]\n        const new_vertex: vec3 = [\n            Number(components[1]).valueOf(),\n            Number(components[2]).valueOf(),\n            Number(components[3]).valueOf(),\n        ];\n\n        this.v.push(new_vertex);\n    }\n\n    private read_texcoord_data(line: string) {\n        const components = line.split(\" \");\n        // [\"vt\", \"u\", \"v\"]\n        const new_texcoord: vec2 = [\n            Number(components[1]).valueOf(),\n            Number(components[2]).valueOf(),\n        ];\n\n        this.vt.push(new_texcoord);\n    }\n\n    private read_normal_data(line: string) {\n        const components = line.split(\" \");\n        // [\"vn\", \"nx\", \"ny\", \"nz\"]\n        const new_normal: vec3 = [\n            Number(components[1]).valueOf(),\n            Number(components[2]).valueOf(),\n            Number(components[3]).valueOf(),\n        ];\n\n        this.vn.push(new_normal);\n    }\n\n    private read_face_data(line: string, result: number[]) {\n        line = line.replace(\"\\n\", \"\");\n        const vertex_descriptions = line.split(\" \");\n        // [\"f\", \"v1\", \"v2\", ...]\n        /*\n            triangle fan setup, eg.\n            v1 v2 v3 v4 => (v1, v2, v3), (v1, v3, v4)\n\n            no. of triangles = no. of vertices - 2\n        */\n\n        const triangle_count = vertex_descriptions.length - 3; // accounting also for \"f\"\n        for (var i = 0; i < triangle_count; i++) {\n            //corner a\n            this.read_corner(vertex_descriptions[1], result);\n            this.read_corner(vertex_descriptions[2 + i], result);\n            this.read_corner(vertex_descriptions[3 + i], result);\n        }\n    }\n\n    private read_corner(vertex_description: string, result: number[]) {\n        const v_vt_vn = vertex_description.split(\"/\");\n        const v = this.v[Number(v_vt_vn[0]).valueOf() - 1];\n        const vt = this.vt[Number(v_vt_vn[1]).valueOf() - 1];\n        const vn = this.vn[Number(v_vt_vn[2]).valueOf() - 1];\n        //ignoring normals for now\n        result.push(v[0]);\n        result.push(v[1]);\n        result.push(v[2]);\n        result.push(vt[0]);\n        result.push(vt[1]);\n        result.push(vn[0]);\n        result.push(vn[1]);\n        result.push(vn[2]);\n    }\n}\n","/** Describes lights structs in shaders.wgsl\n * struct PointLight {\n *      position : vec3f,\n *      color : vec3f,\n *   };\n *    struct LightStorage {\n *       pointCount : u32,\n *       point : array<PointLight>,\n *   };\n *\n */\n\nimport { vec3 } from \"gl-matrix\";\n\nexport class Lights {\n    buffer: GPUBuffer;\n\n    // Light data\n    max_lights: number;\n    storage: PointLight[] = [];\n\n    constructor(max_lights: number = 10) {\n        // For now lets initialize with 1 light\n        this.max_lights = max_lights;\n    }\n\n    public async init(device: GPUDevice) {\n        // Create runtime size buffer 10 lights max for now (strange aligns see wgsl)\n        const size = 16 + 32 * this.max_lights;\n        const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;\n        const descriptor: GPUBufferDescriptor = {\n            label: \"Lights\",\n            size: size,\n            usage: usage,\n        };\n\n        this.buffer = device.createBuffer(descriptor);\n\n        // Write initial data\n        this.writeBuffer(device);\n    }\n    public writeBuffer(device: GPUDevice) {\n        device.queue.writeBuffer(\n            this.buffer,\n            0,\n            new Uint32Array([this.storage.length])\n        );\n        for (let i = 0; i < this.storage.length; i++) {\n            const light = this.storage[i];\n            device.queue.writeBuffer(\n                this.buffer,\n                16 + i * 32,\n                <ArrayBuffer>light.position\n            );\n            device.queue.writeBuffer(\n                this.buffer,\n                32 + i * 32,\n                <ArrayBuffer>light.color\n            );\n        }\n    }\n\n    public addLight(device: GPUDevice, position: vec3, color: vec3) {\n        const newLight = new PointLight(position, color);\n        this.storage.push(newLight);\n\n        // Write new data\n        this.writeBuffer(device);\n    }\n}\n\nexport class PointLight {\n    position: vec3;\n    color: vec3;\n\n    constructor(position: vec3, color: vec3) {\n        this.position = position;\n        this.color = color;\n    }\n}\n","import { mat4, vec3 } from \"gl-matrix\";\nimport { ImageMaterial } from \"./assets/ImageMaterial\";\nimport { ObjMesh } from \"./assets/ObjMesh\";\nimport { Asset } from \"./assets/assets\";\nimport { Lights, PointLight } from \"./assets/lights\";\n\n/** Am not too sure if traditionally this is a scene\n * in game engine terms, but for me it makes sense\n * to put all the objects / assets here.\n */\nexport interface Scene {\n    assets: Map<string, Asset>;\n    lights: Lights;\n\n    init(device: GPUDevice): Promise<void>;\n}\n\nexport class CheckerScene implements Scene {\n    assets: Map<string, Asset>;\n    lights: Lights;\n\n    constructor() {\n        // This scene contains a table, a chessboard and the checkers\n        const sources = [\n            {\n                name: \"table\",\n                src: \"assets/table.obj\",\n                img: \"assets/table.png\",\n                n: 1,\n            },\n            {\n                name: \"chessboard\",\n                src: \"assets/chessboard.obj\",\n                img: \"assets/chessboard.png\",\n                n: 1,\n            },\n\n            {\n                name: \"klingon\",\n                src: \"assets/klingon.obj\",\n                img: \"assets/klingon.png\",\n                n: 0,\n            },\n            {\n                name: \"command\",\n                src: \"assets/command.obj\",\n                img: \"assets/command.png\",\n                n: 0,\n            },\n            {\n                name: \"preview\",\n                src: \"assets/preview.obj\",\n                img: \"assets/preview.png\",\n                n: 0,\n            },\n        ];\n        this.assets = new Map<string, Asset>();\n        for (const source of sources) {\n            this.assets.set(source.name, {\n                mesh: new ObjMesh(source.src),\n                material: new ImageMaterial(source.img, 0, true, false), // blender flips the image\n                modelMatrix: Array.from({ length: source.n }, () =>\n                    mat4.create()\n                ),\n                modelMatrixBuffer: null as any,\n                highlight: [false],\n                highlightBuffer: null as any,\n            });\n        }\n\n        // Add lights above the table\n        this.lights = new Lights();\n        this.lights.storage.push(\n            new PointLight(vec3.fromValues(-3, 0, 3), vec3.fromValues(1, 1, 1))\n        );\n        this.lights.storage.push(\n            new PointLight(vec3.fromValues(3, 0, 3), vec3.fromValues(1, 1, 1))\n        );\n    }\n\n    public async init(device: GPUDevice) {\n        const promises = [];\n        for (const [name, asset] of this.assets) {\n            promises.push(asset.mesh.init(device));\n            promises.push(asset.material.init(device));\n\n            // Create model matrix buffer\n            asset.modelMatrixBuffer = device.createBuffer({\n                label: \"Model Matrix\",\n                size: 64 * 12,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n\n            // Create highlight buffer\n            asset.highlightBuffer = device.createBuffer({\n                label: \"Highlight\",\n                size: 4 * 12,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n        }\n        promises.push(this.lights.init(device));\n        await Promise.all(promises);\n\n        // Write all buffers\n        for (const [name, asset] of this.assets) {\n            for (let i = 0; i < asset.modelMatrix.length; i++) {\n                device.queue.writeBuffer(\n                    asset.modelMatrixBuffer,\n                    i * 64,\n                    <ArrayBuffer>asset.modelMatrix[i]\n                );\n            }\n\n            // binary to decimal\n            const array = new Uint32Array(asset.highlight as []);\n\n            // Convert hightlight to int and write\n            device.queue.writeBuffer(asset.highlightBuffer, 0, array);\n        }\n    }\n}\n","import { mat4, vec3 } from \"gl-matrix\";\nimport { Renderer } from \"../view/renderer\";\nimport { Camera } from \"./camera\";\nimport { CheckerScene, Scene } from \"../view/scene\";\nimport { CellState, CheckersBoard } from \"./checkersBoard\";\nimport { Asset } from \"src/view/assets/assets\";\n\nexport class App {\n    // Objects\n    canvas: HTMLCanvasElement;\n    camera: Camera;\n    renderer: Renderer;\n    scene: Scene;\n    gameboard: CheckersBoard;\n\n    // State\n    _active_piece: {\n        piece: \"command\" | \"klingon\";\n        instance: number;\n        position: [number, number];\n        next_valid_moves: [number, number][];\n    } | null = null;\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.canvas = canvas;\n        this.scene = new CheckerScene();\n        this.camera = new Camera();\n        this.gameboard = new CheckersBoard();\n\n        this.renderer = new Renderer(this.canvas, this.scene, this.camera);\n\n        this.register_handlers();\n    }\n\n    public async init() {\n        // Resize canvas to match parent\n        const cr = this.canvas.parentElement!.getBoundingClientRect();\n        this.canvas.width = cr.width;\n        this.canvas.height = cr.height;\n\n        // Init renderer\n        await this.renderer.init();\n\n        // Set camera to center of board\n        this.camera.set_position(vec3.fromValues(-2, 0, 6));\n        this.camera.set_look_at(vec3.fromValues(0, 0, 3.4));\n        // Write camera data to buffer\n        this.camera.writeBuffer(this.renderer.device);\n\n        // Called once to setup the piece instances\n        this.gameboard.update(\n            this.renderer.device,\n            this.scene.assets.get(\"klingon\") as Asset,\n            this.scene.assets.get(\"command\") as Asset\n        );\n    }\n\n    public run() {\n        var running = true;\n        this.renderer.render(); // Render scene\n        if (running) {\n            requestAnimationFrame(this.run.bind(this));\n        }\n    }\n\n    private register_handlers() {\n        document.addEventListener(\"keydown\", (e) => {\n            this.handle_keydown(e);\n        });\n        document.addEventListener(\"keyup\", (e) => {\n            this.handle_keyup(e);\n        });\n\n        document.addEventListener(\"wheel\", (e) => {\n            this.handle_mousewheel(e as WheelEvent);\n        });\n\n        // Mouse move camera on left click and drag\n        this.canvas.addEventListener(\"mousedown\", (e) => {\n            this.handle_mousedown(e);\n        });\n        this.canvas.addEventListener(\"mouseup\", (e) => {\n            this.handle_mouseup(e);\n        });\n        this.canvas.addEventListener(\"mousemove\", (e) => {\n            this.handle_mousemove(e);\n        });\n        this.canvas.addEventListener(\"wheel\", (e) => {\n            this.handle_mousewheel(e as WheelEvent);\n        });\n        this.canvas.addEventListener(\"click\", (e) => {\n            this.handle_click(e);\n        });\n        this.canvas.addEventListener(\"contextmenu\", (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        // ResizeObserver for canvas parent\n\n        const cb = debounce((entries: ResizeObserverEntry[]) => {\n            for (let entry of entries) {\n                // Get parent dimensions\n                const cr = entry.contentRect;\n                this.renderer.resize(cr.width, cr.height);\n            }\n        }, 100);\n\n        const observer = new ResizeObserver(cb);\n        observer.observe(this.canvas!.parentElement!);\n    }\n\n    private handle_keydown(e: KeyboardEvent) {\n        switch (e.key) {\n            case \"w\":\n                this.camera.position[2] += 0.1;\n                this.camera.set_position(this.camera.position);\n                this.camera.writeBuffer(this.renderer.device);\n                break;\n            case \"a\":\n                this.camera.position[1] -= 0.1;\n                this.camera.set_position(this.camera.position);\n                this.camera.writeBuffer(this.renderer.device);\n                break;\n            case \"s\":\n                this.camera.position[2] -= 0.1;\n                this.camera.set_position(this.camera.position);\n                this.camera.writeBuffer(this.renderer.device);\n\n                break;\n            case \"d\":\n                this.camera.position[1] += 0.1;\n                this.camera.set_position(this.camera.position);\n                this.camera.writeBuffer(this.renderer.device);\n                break;\n            default:\n                break;\n        }\n    }\n\n    private handle_keyup(e: KeyboardEvent) {}\n\n    private handle_mousedown(e: MouseEvent) {\n        if (e.button == 1 || e.button == 2) {\n            e.preventDefault();\n            e.stopPropagation();\n            // Left click\n            this.camera.mouse_down = true;\n        }\n    }\n    private handle_mouseup(e: MouseEvent) {\n        if (e.button == 1 || e.button == 2) {\n            e.preventDefault();\n            e.stopPropagation();\n            // Left click\n            this.camera.mouse_down = false;\n        }\n    }\n\n    private handle_mousemove(e: MouseEvent) {\n        if (this.camera.mouse_down) {\n            // Get relative mouse position to canvas\n            const x = e.clientX - this.canvas.offsetLeft;\n            const y = e.clientY - this.canvas.offsetTop;\n\n            // Get relative mouse movement\n            const dx = x - this.camera.mouse_x;\n            const dy = y - this.camera.mouse_y;\n\n            // Update camera\n            this.camera.position[0] += dy * 0.01;\n            this.camera.position[1] -= dx * 0.01;\n            this.camera.set_position(this.camera.position);\n            this.camera.writeBuffer(this.renderer.device);\n        }\n\n        // Update mouse position\n        this.camera.mouse_x = e.clientX - this.canvas.offsetLeft;\n        this.camera.mouse_y = e.clientY - this.canvas.offsetTop;\n    }\n\n    private handle_mousewheel(e: WheelEvent) {\n        console.log(e);\n    }\n\n    getObjectIDPending = false;\n    private async handle_click(e: MouseEvent) {\n        // Get relative mouse position to canvas\n        if (this.getObjectIDPending) {\n            return;\n        }\n        const x = e.clientX - this.canvas.offsetLeft;\n        const y = e.clientY - this.canvas.offsetTop;\n\n        // Get object ID from renderer (clicked on object)\n        this.getObjectIDPending = true;\n        const [instanceID, MeshID] = await this.renderer.getObjectID(x, y);\n        this.getObjectIDPending = false;\n\n        // Set active piece\n        switch (MeshID) {\n            case 3:\n                this.active_piece = {\n                    piece: \"klingon\",\n                    instance: instanceID,\n                };\n                break;\n            case 4:\n                this.active_piece = {\n                    piece: \"command\",\n                    instance: instanceID,\n                };\n                break;\n            case 5:\n                // Clicked on a valid move\n                if (!this._active_piece) return;\n                const [x, y] = this._active_piece.next_valid_moves[instanceID];\n                this.gameboard.movePiece(\n                    this._active_piece.position[0],\n                    this._active_piece.position[1],\n                    x,\n                    y\n                );\n                this.gameboard.update(\n                    this.renderer.device,\n                    this.scene.assets.get(\"klingon\") as Asset,\n                    this.scene.assets.get(\"command\") as Asset\n                );\n                this.removePreview();\n                this.active_piece = null;\n                break;\n\n            default:\n                console.log(\"Clicked on empty space\");\n                console.log(instanceID, MeshID);\n                return;\n        }\n    }\n\n    private removePreview() {\n        const previews = this.scene.assets.get(\"preview\") as Asset;\n        previews.modelMatrix = [];\n        const a = new Float32Array(previews.modelMatrix as []);\n        this.renderer.device.queue.writeBuffer(\n            previews.modelMatrixBuffer,\n            0,\n            a\n        );\n    }\n\n    private set active_piece(\n        piece: {\n            piece: \"command\" | \"klingon\";\n            instance: number;\n        } | null\n    ) {\n        // Unset previous highlighted piece\n        if (this._active_piece) {\n            const asset = this.scene.assets.get(\n                this._active_piece.piece\n            ) as Asset;\n\n            asset.highlight.fill(false);\n            const array = new Uint32Array(asset.highlight as []);\n            this.renderer.device.queue.writeBuffer(\n                asset.highlightBuffer,\n                0,\n                array\n            );\n        }\n        // Unset previous previews for valid moves\n        this.removePreview();\n        if (!piece) {\n            this._active_piece = null;\n            return;\n        }\n\n        // Update highlight buffer\n        const asset = this.scene.assets.get(piece.piece) as Asset;\n        asset.highlight.fill(false);\n        asset.highlight[piece.instance] = true;\n        const array = new Uint32Array(asset.highlight as []);\n        this.renderer.device.queue.writeBuffer(asset.highlightBuffer, 0, array);\n\n        // Update previews\n        const cellstate =\n            piece.piece == \"klingon\" ? CellState.Klingon : CellState.Command;\n        const position = this.gameboard.get_xy_from_instance(\n            cellstate,\n            piece.instance\n        );\n        if (!position) {\n            return;\n        }\n        const moves = this.gameboard.getValidMoves(position[0], position[1]);\n        const previews = this.scene.assets.get(\"preview\") as Asset;\n        moves.forEach((move, i) => {\n            const mat = mat4.create();\n            mat4.translate(mat, mat, [0.235 * move[1], -0.235 * move[0], 0]);\n            previews.modelMatrix.push(mat);\n            this.renderer.device.queue.writeBuffer(\n                previews.modelMatrixBuffer,\n                i * 64,\n                <ArrayBuffer>previews.modelMatrix[i]\n            );\n        });\n\n        // Set active piece\n        this._active_piece = {\n            piece: piece.piece,\n            instance: piece.instance,\n            position: position,\n            next_valid_moves: moves as [number, number][],\n        };\n    }\n}\n\nfunction debounce(func: Function, timeout = 300) {\n    let timer: any;\n    return (...args: any) => {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            // @ts-ignore\n            func.apply(this, args);\n        }, timeout);\n    };\n}\n","import { App } from \"./logic/app\";\n\nasync function main() {\n    // Init gpu\n    const canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n    const app = new App(canvas);\n    await app.init();\n\n    // Add eventlistener for fullscreen\n    document.addEventListener(\"fullscreenchange\", () => {\n        if (document.fullscreenElement) {\n            const wrapper = document.getElementById(\"wrapper\")!;\n            canvas.width = wrapper.clientWidth;\n            canvas.height = wrapper.clientHeight;\n        } else {\n            canvas.width = 640;\n            canvas.height = 480;\n        }\n    });\n\n    app.run();\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n    await main().catch((e) => {\n        console.error(e);\n        document.getElementById(\"wrapper\")!.innerHTML = e.message;\n    });\n});\n"],"names":["EPSILON","ARRAY_TYPE","Float32Array","Array","create","out","fromValues","x","y","z","Math","random","PI","hypot","i","arguments","length","sqrt","CellState","perspective","fovy","aspect","near","far","nf","f","tan","Infinity","lookAt","eye","center","up","x0","x1","x2","y0","y1","y2","z0","z1","z2","len","eyex","eyey","eyez","upx","upy","upz","centerx","centery","centerz","abs","identity","Renderer","constructor","canvas","initialScene","initialCamera","this","scene","camera","assetBindGroups","Map","pickBindGroups","async","setupWebgpu","createBindGroupLayouts","init","device","createDepthBufferResources","createBindGroups","createRenderPipeline","pipeline","queue","writeBuffer","timeBuffer","performance","now","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","context","getCurrentTexture","createView","clearValue","r","g","b","a","storeOp","loadOp","depthStencilAttachment","setPipeline","setBindGroup","lightsBindGroup","cameraBindGroup","name","asset","assets","num_instances","modelMatrix","get","setVertexBuffer","mesh","buffer","draw","num_vertices","end","submit","finish","pixelX","pixelY","pickInstanceTexture","createTexture","size","width","height","format","usage","GPUTextureUsage","COPY_SRC","RENDER_ATTACHMENT","pickIDTexture","pickDepthTexture","passEncoder","depthClearValue","depthLoadOp","depthStoreOp","pickPipeline","copyTextureToBuffer","mipLevel","texture","origin","pickMapReadBuffer","bytesPerRow","rowsPerImage","offset","mapAsync","GPUMapMode","READ","pickedId","Uint32Array","getMappedRange","pickedInstance","pickedMesh","unmap","ratio","window","devicePixelRatio","canvas_resize","navigator","gpu","Error","adapter","requestAdapter","requestDevice","getContext","configure","alphaMode","lightsBindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","FRAGMENT","type","VERTEX","assetBindGroupLayout","sampler","cameraBindGroupLayout","pickBindGroupLayout","undefined","depthStencilState","depthWriteEnabled","depthCompare","depthBufferDescriptor","depthOrArrayLayers","depthStencilBuffer","depthStencilView","dimension","stencilLoadOp","stencilStoreOp","createBuffer","GPUBufferUsage","UNIFORM","COPY_DST","createBindGroup","layout","resource","lights","bindGroup","material","textureView","modelMatrixBuffer","highlightBuffer","set","pickUniformBuffer","pickBindGroup","MAP_READ","shaderModule","createShaderModule","label","code","createPipelineLayout","bindGroupLayouts","depthStencil","vertex","module","entryPoint","buffers","arrayStride","attributes","shaderLocation","fragment","targets","blend","color","srcFactor","dstFactor","operation","alpha","shaderCodeModule","layoutPick","primitive","topology","cullMode","Camera","mouse_down","mouse_x","mouse_y","projection","position","look_at","descriptor","pixelRatio","set_position","pos","set_look_at","ImageMaterial","path","rotation","verticalFlip","horizontalFlip","imageData","fetch","then","response","blob","createImageBitmap","document","createElement","ctx","translate","rotate","drawImage","scale","loadImageBitmap","baseMipLevel","mipLevelCount","baseArrayLayer","arrayLayerCount","createSampler","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","maxAnisotropy","textureDescriptor","TEXTURE_BINDING","copyExternalImageToTexture","source","ObjMesh","v","vt","vn","lines","fetch_obj","result","forEach","line","read_vertex_data","read_texcoord_data","read_normal_data","read_face_data","vertices","byteLength","bufferLayout","text","split","components","new_vertex","Number","valueOf","push","new_texcoord","new_normal","vertex_descriptions","replace","triangle_count","read_corner","vertex_description","v_vt_vn","Lights","max_lights","storage","STORAGE","light","addLight","newLight","PointLight","CheckerScene","sources","src","img","n","from","highlight","promises","Promise","all","array","CheckersBoard","cells","fill","Empty","get_xy","Klingon","Command","console","log","update","klingon","command","positions","map","cell","index","filter","splice","j","get_index","num_state","player","floor","get_xy_from_instance","piece","instance","found","getValidMoves","moves","state","direction","out_of_bounds","reg_moves","move","jump_moves","x_","y_","enemy","enemy_x","enemy_y","movePiece","fromX","fromY","toX","toY","fromIndex","toIndex","enemy_index","App","_active_piece","getObjectIDPending","gameboard","renderer","register_handlers","cr","parentElement","getBoundingClientRect","run","render","requestAnimationFrame","bind","addEventListener","e","handle_keydown","handle_keyup","handle_mousewheel","handle_mousedown","handle_mouseup","handle_mousemove","handle_click","preventDefault","stopPropagation","cb","func","timeout","timer","args","clearTimeout","setTimeout","apply","debounce","entry","contentRect","resize","ResizeObserver","observe","key","button","clientX","offsetLeft","clientY","offsetTop","dx","dy","instanceID","MeshID","getObjectID","active_piece","next_valid_moves","removePreview","previews","cellstate","mat","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","getElementById","app","fullscreenElement","wrapper","clientWidth","clientHeight","main","catch","error","innerHTML","message"],"sourceRoot":""}