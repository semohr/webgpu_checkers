(()=>{"use strict";var e=1e-6,t="undefined"!=typeof Float32Array?Float32Array:Array;function i(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e,i,a){var r=new t(3);return r[0]=e,r[1]=i,r[2]=a,r}function r(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),i();var s,n=function(e,t,i,a,r){var s,n=1/Math.tan(t/2);return e[0]=n/i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(s=1/(a-r),e[10]=(r+a)*s,e[14]=2*r*a*s):(e[10]=-1,e[14]=-2*a),e};function o(t,i,a,r){var s,n,o,h,c,u,l,f,d,p,g=i[0],m=i[1],v=i[2],b=r[0],w=r[1],y=r[2],x=a[0],B=a[1],_=a[2];return Math.abs(g-x)<e&&Math.abs(m-B)<e&&Math.abs(v-_)<e?function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(t):(l=g-x,f=m-B,d=v-_,s=w*(d*=p=1/Math.hypot(l,f,d))-y*(f*=p),n=y*(l*=p)-b*d,o=b*f-w*l,(p=Math.hypot(s,n,o))?(s*=p=1/p,n*=p,o*=p):(s=0,n=0,o=0),h=f*o-d*n,c=d*s-l*o,u=l*n-f*s,(p=Math.hypot(h,c,u))?(h*=p=1/p,c*=p,u*=p):(h=0,c=0,u=0),t[0]=s,t[1]=h,t[2]=l,t[3]=0,t[4]=n,t[5]=c,t[6]=f,t[7]=0,t[8]=o,t[9]=u,t[10]=d,t[11]=0,t[12]=-(s*g+n*m+o*v),t[13]=-(h*g+c*m+u*v),t[14]=-(l*g+f*m+d*v),t[15]=1,t)}class h{constructor(e,t,i){this.canvas=e,this.scene=t,this.camera=i,this.assetBindGroups=new Map,this.pickBindGroups=new Map}async init(){await this.setupWebgpu(),await this.createBindGroupLayouts(),await this.scene.init(this.device),await this.camera.init(this.device,this.canvas),await this.createDepthBufferResources(),await this.createBindGroups(),await this.createRenderPipeline()}async render(){if(!this.device||!this.pipeline)return;this.device.queue.writeBuffer(this.timeBuffer,0,new Float32Array([performance.now()/1e3]));const e=this.device.createCommandEncoder(),t=e.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},storeOp:"store",loadOp:"clear"}],depthStencilAttachment:this.depthStencilAttachment});t.setPipeline(this.pipeline),t.setBindGroup(0,this.lightsBindGroup),t.setBindGroup(1,this.cameraBindGroup);for(const[e,i]of this.scene.assets){const a=i.modelMatrix.length;t.setBindGroup(2,this.assetBindGroups.get(e)),t.setVertexBuffer(0,i.mesh.buffer),t.draw(i.mesh.num_vertices,a)}t.end(),this.device.queue.submit([e.finish()])}async getObjectID(e,t){const i=this.device.createTexture({size:[this.canvas.width,this.canvas.height,1],format:"r32uint",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT}),a=this.device.createTexture({size:[this.canvas.width,this.canvas.height,1],format:"r32uint",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT}),r=this.device.createTexture({size:[this.canvas.width,this.canvas.height,1],format:"depth24plus",usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT}),s=this.device.createCommandEncoder(),n=s.beginRenderPass({colorAttachments:[{view:i.createView(),clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"},{view:a.createView(),clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:r.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});n.setPipeline(this.pickPipeline),n.setBindGroup(0,this.cameraBindGroup);for(const[e,t]of this.scene.assets){const i=t.modelMatrix.length;n.setBindGroup(1,this.pickBindGroups.get(e)),n.setVertexBuffer(0,t.mesh.buffer),n.draw(t.mesh.num_vertices,i)}n.end(),s.copyTextureToBuffer({mipLevel:0,texture:i,origin:{x:e,y:t}},{buffer:this.pickMapReadBuffer,bytesPerRow:66304,rowsPerImage:1},{width:1}),s.copyTextureToBuffer({mipLevel:0,texture:a,origin:{x:e,y:t}},{buffer:this.pickMapReadBuffer,bytesPerRow:66304,rowsPerImage:1,offset:4},{width:1}),this.device.queue.submit([s.finish()]),await this.pickMapReadBuffer.mapAsync(GPUMapMode.READ,0,8);const o=new Uint32Array(this.pickMapReadBuffer.getMappedRange(0,8)),h=o[0],c=o[1];return this.pickMapReadBuffer.unmap(),[h,c]}async resize(e,t){if(!this.device||!this.pipeline)return;const i=window.devicePixelRatio||1;this.canvas.width=e*i,this.canvas.height=t*i,this.camera.canvas_resize(this.device,this.canvas),await this.createDepthBufferResources()}async setupWebgpu(){if(!navigator.gpu)throw new Error("WebGPU not supported");const e=await navigator.gpu.requestAdapter();if(!e)throw Error("Couldn't request WebGPU adapter.");if(this.adapter=e,this.device=await this.adapter.requestDevice(),!this.device)throw Error("Couldn't request WebGPU device.");const t=this.canvas.getContext("webgpu");if(!t)throw Error("Couldn't get WebGPU context.");this.context=t,this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}async createBindGroupLayouts(){this.lightsBindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.assetBindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),this.cameraBindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),this.pickBindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]})}async createDepthBufferResources(){null==this.depthStencilState&&(this.depthStencilState={format:"depth24plus-stencil8",depthWriteEnabled:!0,depthCompare:"less-equal"});const e={size:{width:this.canvas.width,height:this.canvas.height,depthOrArrayLayers:1},format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT};this.depthStencilBuffer=this.device.createTexture(e),this.depthStencilView=this.depthStencilBuffer.createView({format:"depth24plus-stencil8",dimension:"2d",aspect:"all"}),this.depthStencilAttachment={view:this.depthStencilView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilLoadOp:"clear",stencilStoreOp:"discard"}}async createBindGroups(){this.timeBuffer=this.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.lightsBindGroup=this.device.createBindGroup({layout:this.lightsBindGroupLayout,entries:[{binding:0,resource:{buffer:this.scene.lights.buffer}},{binding:1,resource:{buffer:this.timeBuffer}}]});for(const[e,t]of this.scene.assets){const i=this.device.createBindGroup({layout:this.assetBindGroupLayout,entries:[{binding:0,resource:t.material.sampler},{binding:1,resource:t.material.textureView},{binding:2,resource:{buffer:t.modelMatrixBuffer}},{binding:3,resource:{buffer:t.highlightBuffer}}]});this.assetBindGroups.set(e,i)}this.cameraBindGroup=this.device.createBindGroup({layout:this.cameraBindGroupLayout,entries:[{binding:0,resource:{buffer:this.camera.buffer}}]});let e=1;for(const[t,i]of this.scene.assets){const a=this.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(a,0,new Uint32Array([e]));const r=this.device.createBindGroup({layout:this.pickBindGroupLayout,entries:[{binding:0,resource:{buffer:a}},{binding:1,resource:{buffer:i.modelMatrixBuffer}}]});this.pickBindGroups.set(t,r),e++}this.pickMapReadBuffer=this.device.createBuffer({size:8,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})}async createRenderPipeline(){const e=this.device.createShaderModule({label:"RenderShaderModule",code:"// Everything static in the scene (lighting, projection)\nstruct PointLight {\n    position : vec3f, // offset(0) align(16) size(12)\n    color : vec3f, // offset(16) align(16) size(12)\n};\nstruct LightStorage {\n    pointCount : u32, // offset(0) align(4) size(4)\n    @align(16) point : array<PointLight> // offset(16) align(16) size(24)\n};\n@group(0) @binding(0) var<storage> lights : LightStorage;\n@group(0) @binding(1) var<uniform> time : f32;\n\nstruct Camera {\n    projection : mat4x4f,\n    view : mat4x4f,\n    pos: vec4f,\n};\n@group(1) @binding(0) var<uniform> camera : Camera;\n\n\n\n// Texture, sampler and everything regarding the current vertices\n@group(2) @binding(0) var baseColorSampler : sampler;\n@group(2) @binding(1) var baseColorTexture : texture_2d<f32>;\n@group(2) @binding(2) var<storage> instanceBuffer : array<mat4x4f>; // Model matrix for each instance\n@group(2) @binding(3) var<storage> highlightBuffer : array<u32>; // Model matrix for each instance\n\n// The remainder of this shader doesn't affect the bind groups.\nstruct VertexOutput {\n    @builtin(position) position : vec4f,\n    @location(0) texcoord : vec2f,\n    @location(1) normal : vec3f,\n    @location(2) instanceID : u32,\n};\n\n\n@vertex \nfn vertexMain(\n    @builtin(instance_index) ID : u32,\n    @location(0) position : vec3f,\n    @location(1) texcoord : vec2f,\n    @location(2) normal : vec3f,\n) -> VertexOutput {\n    var output : VertexOutput;\n    // Todo determine model matrix via gameboard\n    output.position = camera.projection * camera.view * instanceBuffer[ID] * vec4f(position, 1.0);\n    output.texcoord = texcoord;\n    output.normal = normal;\n    output.instanceID = ID;\n    return output;\n}\n\n\n\n@fragment\nfn fragmentMain(\n    fragData: VertexOutput\n) -> @location(0) vec4f {\n    // Sample the base color of the surface from a texture.\n    var baseColor = textureSample(baseColorTexture, baseColorSampler, fragData.texcoord);\n\n    let N = normalize(fragData.normal.xyz);\n    let viewDir = normalize(camera.pos - fragData.position);\n    var surfaceColor = vec3f(0.2);\n\n    // directional light from top\n    let lightDir = normalize(vec3f(0.0, 0.0, 1.0));\n    let diff = max(dot(N, lightDir), 0.0);\n    let ambient = vec3f(0.1) * 1.0;\n    let diffuse = vec3f(1.) * diff * 0.8;\n    let result = ambient + diffuse;\n    surfaceColor += result;\n\n    // point lights\n    for (var i = 0u; i < lights.pointCount; i++) {\n        surfaceColor += calcPointLight(fragData, lights.point[i], N, viewDir.xyz);\n    }\n\n    // Apply the base color to the surface.\n    surfaceColor *= baseColor.rgb;\n\n    // Hihglight blinking\n    if (highlightBuffer[fragData.instanceID] == 1u) {\n         // Oscillate alpha between 0.5 and 1 ease in and out\n        let alpha = 0.5 + 0.5 * abs(sin(time * 3.));\n        surfaceColor += vec3f(0.8, 0.1, 0.1) * alpha;\n    }\n\n    // Preview of turn\n\n    // Return the accumulated surface color.\n    return vec4f(surfaceColor, baseColor.a);\n}\n\n\nfn calcPointLight(fragData: VertexOutput, light: PointLight, N: vec3f, viewDir: vec3f) -> vec3f {\n    // Add as group at some point\n    let DIFFUSE = vec3f(1.0) * light.color.rgb;\n    let AMBIENT = vec3f(1.0) * light.color.rgb;\n    let SPECULAR = vec3f(1.0) * light.color.rgb;\n    let SHININESS = 100.0;\n    // point let config (could also be moved to a storage buffer)\n    let CONSTANT = 1.0;\n    let LINEAR = 0.09;\n    let QUARDRATIC = 0.032;\n\n    let lightDir = normalize(light.position.xyz - fragData.position.xyz);\n    // diffuse shading\n    let diff = max(dot(N, lightDir), 0.0);\n    // specular shading\n    let reflectDir = reflect(-lightDir, N);\n    let spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);\n    // attenuation\n    let distance = length(light.position.xyz - fragData.position.xyz) / 80.0;\n    let attenuation = 1.0 / (CONSTANT + LINEAR * distance + QUARDRATIC * (distance * distance));\n\n    // combine results\n    var ambient = AMBIENT  * 1.0 * attenuation;\n    var diffuse = DIFFUSE * diff * 1.0 * attenuation;\n    var specular = SPECULAR * spec * 1.0 * attenuation;\n\n    let result = ambient + diffuse + specular;\n    return result;\n}"}),t=this.device.createPipelineLayout({bindGroupLayouts:[this.lightsBindGroupLayout,this.cameraBindGroupLayout,this.assetBindGroupLayout]});this.pipeline=this.device.createRenderPipeline({label:"renderPipeline",layout:t,depthStencil:this.depthStencilState,vertex:{module:e,entryPoint:"vertexMain",buffers:[{arrayStride:32,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}]}]},fragment:{module:e,entryPoint:"fragmentMain",targets:[{format:this.format,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}}}]}});const i=this.device.createShaderModule({label:"PickShaderModule",code:"struct Camera {\n    projection : mat4x4f,\n    view : mat4x4f,\n    pos: vec4f,\n};\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n\n@group(1) @binding(0) var<uniform> pickUniform : u32; // Picking ID\n@group(1) @binding(1) var<storage> instanceBuffer : array<mat4x4f>; // Model matrix for each instance\n\n// The remainder of this shader doesn't affect the bind groups.\nstruct VertexOutput {\n    @builtin(position) position : vec4f,\n    @location(0) texcoord : vec2f,\n    @location(1) normal : vec3f,\n    @location(2) instanceID : u32\n};\n\n\n@vertex \nfn pickingVertexMain(\n    @builtin(instance_index) ID : u32,\n    @location(0) position : vec3f,\n    @location(1) texcoord : vec2f,\n    @location(2) normal : vec3f,\n) -> VertexOutput {\n    var output : VertexOutput;\n    // Todo determine model matrix via gameboard\n    output.position = camera.projection * camera.view * instanceBuffer[ID] * vec4f(position, 1.0);\n    output.texcoord = texcoord;\n    output.normal = normal;\n    output.instanceID = ID;\n    return output;\n}\n\n\n\nstruct ReturnFragment {\n    @location(0) instance_id : u32,\n    @location(1) pickID : u32\n};\n\n@fragment\nfn pickingFragmentMain(\n    fragData: VertexOutput\n) -> ReturnFragment {\n    var r : ReturnFragment;\n    r.instance_id = fragData.instanceID;\n    r.pickID = pickUniform;\n    return r;\n}\n"}),a=this.device.createPipelineLayout({bindGroupLayouts:[this.cameraBindGroupLayout,this.pickBindGroupLayout]});this.pickPipeline=this.device.createRenderPipeline({label:"PickerPipeline",layout:a,vertex:{module:i,entryPoint:"pickingVertexMain",buffers:[{arrayStride:32,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}]}]},fragment:{module:i,entryPoint:"pickingFragmentMain",targets:[{format:"r32uint"},{format:"r32uint"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}})}}class c{constructor(){this.mouse_down=!1,this.mouse_x=0,this.mouse_y=0,this.projection=r(),this.view=r(),this.position=i()}async init(e,t){n(this.projection,Math.PI/4,t.width/t.height,.1,1e3),this.position=a(0,0,100),this.look_at=a(0,0,0),o(this.view,this.position,this.look_at,[0,0,1]);const i={label:"Camera",size:144,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};this.buffer=e.createBuffer(i),this.writeBuffer(e)}writeBuffer(e){e.queue.writeBuffer(this.buffer,0,this.projection),e.queue.writeBuffer(this.buffer,64,this.view),e.queue.writeBuffer(this.buffer,128,this.position)}canvas_resize(e,t){const i=window.devicePixelRatio||1;n(this.projection,Math.PI/4,t.width*i/(t.height*i),.1,1e3),e.queue.writeBuffer(this.buffer,0,this.projection)}set_position(e){this.position=e,o(this.view,this.position,this.look_at,[0,0,1])}set_look_at(e){this.look_at=e,o(this.view,this.position,this.look_at,[0,0,1])}}class u{constructor(e,t=0,i=!1,a=!1){this.path=e,this.rotation=t,this.verticalFlip=i,this.horizontalFlip=a}async init(e){var t=await fetch(this.path).then((async e=>await e.blob())).then((async e=>await createImageBitmap(e)));if(0!=this.rotation){const e=document.createElement("canvas"),i=e.getContext("2d");e.width=t.width,e.height=t.height,i.translate(e.width/2,e.height/2),i.rotate(this.rotation*Math.PI/180),i.drawImage(t,-t.width/2,-t.height/2),t=await createImageBitmap(e)}if(this.verticalFlip||this.horizontalFlip){const e=document.createElement("canvas"),i=e.getContext("2d");e.width=t.width,e.height=t.height,this.verticalFlip&&(i.translate(0,e.height),i.scale(1,-1)),this.horizontalFlip&&(i.translate(e.width,0),i.scale(-1,1)),i.drawImage(t,0,0),t=await createImageBitmap(e)}await this.loadImageBitmap(e,t),this.textureView=this.texture.createView({format:"rgba8unorm",dimension:"2d",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:1}),this.sampler=e.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1})}async loadImageBitmap(e,t){const i={size:[t.width,t.height],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};this.texture=e.createTexture(i),e.queue.copyExternalImageToTexture({source:t},{texture:this.texture},i.size)}}class l{constructor(e){this.v=[],this.vt=[],this.vn=[],this.path=e}async init(e){const t=await this.fetch_obj(this.path);var i=[];t.forEach((e=>{"v"==e[0]&&" "==e[1]?this.read_vertex_data(e):"v"==e[0]&&"t"==e[1]?this.read_texcoord_data(e):"v"==e[0]&&"n"==e[1]?this.read_normal_data(e):"f"==e[0]&&this.read_face_data(e,i)})),this.vertices=new Float32Array(i),this.num_vertices=this.vertices.length/8;const a=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,r={label:"Obj vertices"+this.path,size:this.vertices.byteLength,usage:a};this.buffer=e.createBuffer(r),e.queue.writeBuffer(this.buffer,0,this.vertices),this.bufferLayout={arrayStride:32,attributes:[{format:"float32x3",offset:0,shaderLocation:0},{format:"float32x2",offset:12,shaderLocation:1},{format:"float32x3",offset:20,shaderLocation:2}]}}async fetch_obj(e){return await fetch(e).then((e=>e.blob())).then((e=>e.text())).then((e=>e.split("\n")))}read_vertex_data(e){const t=e.split(" "),i=[Number(t[1]).valueOf(),Number(t[2]).valueOf(),Number(t[3]).valueOf()];this.v.push(i)}read_texcoord_data(e){const t=e.split(" "),i=[Number(t[1]).valueOf(),Number(t[2]).valueOf()];this.vt.push(i)}read_normal_data(e){const t=e.split(" "),i=[Number(t[1]).valueOf(),Number(t[2]).valueOf(),Number(t[3]).valueOf()];this.vn.push(i)}read_face_data(e,t){const i=(e=e.replace("\n","")).split(" "),a=i.length-3;for(var r=0;r<a;r++)this.read_corner(i[1],t),this.read_corner(i[2+r],t),this.read_corner(i[3+r],t)}read_corner(e,t){const i=e.split("/"),a=this.v[Number(i[0]).valueOf()-1],r=this.vt[Number(i[1]).valueOf()-1],s=this.vn[Number(i[2]).valueOf()-1];t.push(a[0]),t.push(a[1]),t.push(a[2]),t.push(r[0]),t.push(r[1]),t.push(s[0]),t.push(s[1]),t.push(s[2])}}class f{constructor(e=10){this.storage=[],this.max_lights=e}async init(e){const t={label:"Lights",size:16+32*this.max_lights,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST};this.buffer=e.createBuffer(t),this.writeBuffer(e)}writeBuffer(e){e.queue.writeBuffer(this.buffer,0,new Uint32Array([this.storage.length]));for(let t=0;t<this.storage.length;t++){const i=this.storage[t];e.queue.writeBuffer(this.buffer,16+32*t,i.position),e.queue.writeBuffer(this.buffer,32+32*t,i.color)}}addLight(e,t,i){const a=new d(t,i);this.storage.push(a),this.writeBuffer(e)}}class d{constructor(e,t){this.position=e,this.color=t}}class p{constructor(){const e=[{name:"table",src:"assets/table.obj",img:"assets/table.png",n:1},{name:"chessboard",src:"assets/chessboard.obj",img:"assets/chessboard.png",n:1},{name:"klingon",src:"assets/klingon.obj",img:"assets/klingon.png",n:0},{name:"command",src:"assets/command.obj",img:"assets/command.png",n:0},{name:"preview",src:"assets/preview.obj",img:"assets/preview.png",n:0}];this.assets=new Map;for(const t of e)this.assets.set(t.name,{mesh:new l(t.src),material:new u(t.img,0,!0,!1),modelMatrix:Array.from({length:t.n},(()=>r())),modelMatrixBuffer:null,highlight:[!1],highlightBuffer:null});this.lights=new f,this.lights.storage.push(new d(a(-3,0,3),a(1,1,1))),this.lights.storage.push(new d(a(3,0,3),a(1,1,1)))}async init(e){const t=[];for(const[i,a]of this.assets)t.push(a.mesh.init(e)),t.push(a.material.init(e)),a.modelMatrixBuffer=e.createBuffer({label:"Model Matrix",size:768,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),a.highlightBuffer=e.createBuffer({label:"Highlight",size:48,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});t.push(this.lights.init(e)),await Promise.all(t);for(const[t,i]of this.assets){for(let t=0;t<i.modelMatrix.length;t++)e.queue.writeBuffer(i.modelMatrixBuffer,64*t,i.modelMatrix[t]);const t=new Uint32Array(i.highlight);e.queue.writeBuffer(i.highlightBuffer,0,t)}}}!function(e){e[e.Empty=0]="Empty",e[e.Klingon=1]="Klingon",e[e.Command=2]="Command"}(s||(s={}));class g{constructor(){this.width=8,this.height=8,this.cells=new Array(this.width*this.height),this.cells.fill(s.Empty);for(let e=0;e<this.cells.length;e++){const[t,i]=this.get_xy(e);t%2==i%2&&(i<3?this.cells[e]=s.Klingon:i>4&&(this.cells[e]=s.Command))}console.log(this.cells)}update(e,t,i){[t,i].forEach(((t,i)=>{const a=this.cells.map(((e,t)=>{if(e==i+1)return this.get_xy(t)})).filter((e=>null!=e));if(a.length!=t.modelMatrix.length)if(a.length<t.modelMatrix.length)t.modelMatrix.splice(a.length);else for(let e=t.modelMatrix.length;e<a.length;e++)t.modelMatrix.push(r());a.forEach(((i,a)=>{const[r,s]=i;var n,o;o=[.235*s,-.235*r,0],(n=t.modelMatrix[a])[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=o[0],n[13]=o[1],n[14]=o[2],n[15]=1,e.queue.writeBuffer(t.modelMatrixBuffer,64*a,t.modelMatrix[a])}))}))}get_index(e,t){return this.width*t+e}num_state(e){return this.cells.filter((t=>t==e)).length}get_xy(e){return[e%this.width,Math.floor(e/this.width)]}get_xy_from_instance(e,t){let i=0;for(let a=0;a<this.cells.length;a++)if(this.cells[a]==e){if(i==t)return this.get_xy(a);i++}}getValidMoves(e,t){const i=[],a=this.cells[this.get_index(e,t)];if(a!=s.Klingon&&a!=s.Command)return i;const r=a==s.Klingon?1:-1,n=(e,t)=>e<0||t<0||e>=this.width||t>=this.height,o=[[e-1,t+r],[e+1,t+r]];i.push(...o.filter((e=>{const[t,i]=e;return!n(t,i)&&this.cells[this.get_index(t,i)]==s.Empty})));const h=[[e-2,t+2*r],[e+2,t+2*r]];return i.push(...h.filter((i=>{const[r,o]=i;if(n(r,o))return!1;if(this.cells[this.get_index(r,o)]!=s.Empty)return!1;const h=a==s.Klingon?2:1,c=(e+r)/2,u=(t+o)/2;return this.cells[this.get_index(c,u)]==h}))),i}movePiece(e,t,i,a){const r=this.get_index(e,t),n=this.get_index(i,a);this.cells[n]=this.cells[r],this.cells[r]=s.Empty;const o=this.cells[n]==s.Klingon?2:1,h=(e+i)/2,c=(t+a)/2,u=this.get_index(h,c);this.cells[u]==o&&(this.cells[u]=s.Empty)}}class m{constructor(e){this._active_piece=null,this.getObjectIDPending=!1,this.canvas=e,this.scene=new p,this.camera=new c,this.gameboard=new g,this.renderer=new h(this.canvas,this.scene,this.camera),this.register_handlers()}async init(){const e=this.canvas.parentElement.getBoundingClientRect();this.canvas.width=e.width,this.canvas.height=e.height,await this.renderer.init(),this.camera.set_position(a(-2,0,6)),this.camera.set_look_at(a(0,0,3.4)),this.camera.writeBuffer(this.renderer.device),this.gameboard.update(this.renderer.device,this.scene.assets.get("klingon"),this.scene.assets.get("command"))}run(){this.renderer.render(),requestAnimationFrame(this.run.bind(this))}register_handlers(){document.addEventListener("keydown",(e=>{this.handle_keydown(e)})),document.addEventListener("keyup",(e=>{this.handle_keyup(e)})),document.addEventListener("wheel",(e=>{this.handle_mousewheel(e)})),this.canvas.addEventListener("mousedown",(e=>{this.handle_mousedown(e)})),this.canvas.addEventListener("mouseup",(e=>{this.handle_mouseup(e)})),this.canvas.addEventListener("mousemove",(e=>{this.handle_mousemove(e)})),this.canvas.addEventListener("wheel",(e=>{this.handle_mousewheel(e)})),this.canvas.addEventListener("click",(e=>{this.handle_click(e)})),this.canvas.addEventListener("contextmenu",(e=>{e.preventDefault(),e.stopPropagation()}));const e=function(e,t=300){let i;return(...a)=>{clearTimeout(i),i=setTimeout((()=>{e.apply(this,a)}),t)}}((e=>{for(let t of e){const e=t.contentRect;this.renderer.resize(e.width,e.height)}}),100);new ResizeObserver(e).observe(this.canvas.parentElement)}handle_keydown(e){switch(e.key){case"w":this.camera.position[2]+=.1,this.camera.set_position(this.camera.position),this.camera.writeBuffer(this.renderer.device);break;case"a":this.camera.position[1]-=.1,this.camera.set_position(this.camera.position),this.camera.writeBuffer(this.renderer.device);break;case"s":this.camera.position[2]-=.1,this.camera.set_position(this.camera.position),this.camera.writeBuffer(this.renderer.device);break;case"d":this.camera.position[1]+=.1,this.camera.set_position(this.camera.position),this.camera.writeBuffer(this.renderer.device)}}handle_keyup(e){}handle_mousedown(e){1!=e.button&&2!=e.button||(e.preventDefault(),e.stopPropagation(),this.camera.mouse_down=!0)}handle_mouseup(e){1!=e.button&&2!=e.button||(e.preventDefault(),e.stopPropagation(),this.camera.mouse_down=!1)}handle_mousemove(e){if(this.camera.mouse_down){const t=e.clientX-this.canvas.offsetLeft,i=e.clientY-this.canvas.offsetTop,a=t-this.camera.mouse_x,r=i-this.camera.mouse_y;this.camera.position[0]+=.01*r,this.camera.position[1]-=.01*a,this.camera.set_position(this.camera.position),this.camera.writeBuffer(this.renderer.device)}this.camera.mouse_x=e.clientX-this.canvas.offsetLeft,this.camera.mouse_y=e.clientY-this.canvas.offsetTop}handle_mousewheel(e){console.log(e)}async handle_click(e){if(this.getObjectIDPending)return;const t=e.clientX-this.canvas.offsetLeft,i=e.clientY-this.canvas.offsetTop;this.getObjectIDPending=!0;const[a,r]=await this.renderer.getObjectID(t,i);switch(this.getObjectIDPending=!1,r){case 3:this.active_piece={piece:"klingon",instance:a};break;case 4:this.active_piece={piece:"command",instance:a};break;case 5:if(!this._active_piece)return;const[e,t]=this._active_piece.next_valid_moves[a];this.gameboard.movePiece(this._active_piece.position[0],this._active_piece.position[1],e,t),this.gameboard.update(this.renderer.device,this.scene.assets.get("klingon"),this.scene.assets.get("command")),this.removePreview(),this.active_piece=null;break;default:return console.log("Clicked on empty space"),void console.log(a,r)}}removePreview(){const e=this.scene.assets.get("preview");e.modelMatrix=[];const t=new Float32Array(e.modelMatrix);this.renderer.device.queue.writeBuffer(e.modelMatrixBuffer,0,t)}set active_piece(e){if(this._active_piece){const e=this.scene.assets.get(this._active_piece.piece);e.highlight.fill(!1);const t=new Uint32Array(e.highlight);this.renderer.device.queue.writeBuffer(e.highlightBuffer,0,t)}if(this.removePreview(),!e)return void(this._active_piece=null);const t=this.scene.assets.get(e.piece);t.highlight.fill(!1),t.highlight[e.instance]=!0;const i=new Uint32Array(t.highlight);this.renderer.device.queue.writeBuffer(t.highlightBuffer,0,i);const a="klingon"==e.piece?s.Klingon:s.Command,n=this.gameboard.get_xy_from_instance(a,e.instance);if(!n)return;const o=this.gameboard.getValidMoves(n[0],n[1]),h=this.scene.assets.get("preview");o.forEach(((e,t)=>{const i=r();var a,s,n,o,c,u,l,f,d,p,g,m,v,b,w,y,x,B;a=i,s=i,y=(n=[.235*e[1],-.235*e[0],0])[0],x=n[1],B=n[2],s===a?(a[12]=s[0]*y+s[4]*x+s[8]*B+s[12],a[13]=s[1]*y+s[5]*x+s[9]*B+s[13],a[14]=s[2]*y+s[6]*x+s[10]*B+s[14],a[15]=s[3]*y+s[7]*x+s[11]*B+s[15]):(o=s[0],c=s[1],u=s[2],l=s[3],f=s[4],d=s[5],p=s[6],g=s[7],m=s[8],v=s[9],b=s[10],w=s[11],a[0]=o,a[1]=c,a[2]=u,a[3]=l,a[4]=f,a[5]=d,a[6]=p,a[7]=g,a[8]=m,a[9]=v,a[10]=b,a[11]=w,a[12]=o*y+f*x+m*B+s[12],a[13]=c*y+d*x+v*B+s[13],a[14]=u*y+p*x+b*B+s[14],a[15]=l*y+g*x+w*B+s[15]),h.modelMatrix.push(i),this.renderer.device.queue.writeBuffer(h.modelMatrixBuffer,64*t,h.modelMatrix[t])})),this._active_piece={piece:e.piece,instance:e.instance,position:n,next_valid_moves:o}}}document.addEventListener("DOMContentLoaded",(async()=>{await async function(){const e=document.getElementById("canvas"),t=new m(e);await t.init(),document.addEventListener("fullscreenchange",(()=>{if(document.fullscreenElement){const t=document.getElementById("wrapper");e.width=t.clientWidth,e.height=t.clientHeight}else e.width=640,e.height=480})),t.run()}().catch((e=>{console.error(e),document.getElementById("wrapper").innerHTML=e.message}))}))})();
//# sourceMappingURL=bundle.js.map